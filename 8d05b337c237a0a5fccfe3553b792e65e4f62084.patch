From 8d05b337c237a0a5fccfe3553b792e65e4f62084 Mon Sep 17 00:00:00 2001
From: Patrick Griffis <tingping@tingping.se>
Date: Sun, 18 Nov 2018 17:18:52 -0500
Subject: [PATCH] notify: Use GNotification

This has some downsides such as no button icons but works out of
the box in a sandbox and removes a massive amount of code.
---
 pithos/application.py                 |  12 ++
 pithos/plugins/dbus_util/GioNotify.py | 223 --------------------------
 pithos/plugins/notify.py              | 114 ++++---------
 3 files changed, 47 insertions(+), 302 deletions(-)
 delete mode 100644 pithos/plugins/dbus_util/GioNotify.py

diff --git a/pithos/application.py b/pithos/application.py
index 77d035a7..cac252d4 100644
--- a/pithos/application.py
+++ b/pithos/application.py
@@ -83,6 +83,18 @@ def do_startup(self):
         action.connect("activate", self.quit_cb)
         self.add_action(action)
 
+        action = Gio.SimpleAction.new("next-song", None)
+        action.connect("activate", lambda action, param: self.window.next_song())
+        self.add_action(action)
+
+        action = Gio.SimpleAction.new("play", None)
+        action.connect("activate", lambda action, param: self.window.user_play())
+        self.add_action(action)
+
+        action = Gio.SimpleAction.new("pause", None)
+        action.connect("activate", lambda action, param: self.window.user_pause())
+        self.add_action(action)
+
         if Gtk.get_major_version() > 3 or Gtk.get_minor_version() >= 20:
             menu = self.get_app_menu()
             it = menu.iterate_item_links(menu.get_n_items() - 1)
diff --git a/pithos/plugins/dbus_util/GioNotify.py b/pithos/plugins/dbus_util/GioNotify.py
deleted file mode 100644
index 2209f905..00000000
--- a/pithos/plugins/dbus_util/GioNotify.py
+++ /dev/null
@@ -1,223 +0,0 @@
-#
-# Copyright (C) 2016 Jason Gray <jasonlevigray3@gmail.com>
-#
-# This program is free software: you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 3, as published
-# by the Free Software Foundation.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranties of
-# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
-# PURPOSE.  See the GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License along
-# with this program.  If not, see <http://www.gnu.org/licenses/>.
-# END LICENSE
-
-# See <https://developer.gnome.org/notification-spec/> and
-# <https://github.com/JasonLG1979/possibly-useful-scraps/wiki/GioNotify>
-# for documentation.
-
-import logging
-
-from enum import Enum
-
-from gi.repository import GLib, GObject, Gio
-
-
-class GioNotify(Gio.DBusProxy):
-
-    # Notification Closed Reason Constants.
-    class Closed(Enum):
-        REASON_EXPIRED = 1
-        REASON_DISMISSED = 2
-        REASON_CLOSEMETHOD = 3
-        REASON_UNDEFINED = 4
-
-        @property
-        def explanation(self):
-            value = self.value
-            if value == 1:
-                return 'The notification expired.'
-            elif value == 2:
-                return 'The notification was dismissed by the user.'
-            elif value == 3:
-                return 'The notification was closed by a call to CloseNotification.'
-            elif value == 4:
-                return 'The notification was closed by undefined/reserved reasons.'
-
-    __gtype_name__ = 'GioNotify'
-    __gsignals__ = {
-        'action-invoked': (GObject.SignalFlags.RUN_FIRST, None, (GObject.TYPE_STRING,)),
-        'closed': (GObject.SignalFlags.RUN_FIRST, None, (GObject.TYPE_PYOBJECT,)),
-    }
-
-    def __init__(self, **kwargs):
-        super().__init__(
-            g_bus_type=Gio.BusType.SESSION,
-            g_interface_name='org.freedesktop.Notifications',
-            g_name='org.freedesktop.Notifications',
-            g_object_path='/org/freedesktop/Notifications',
-            **kwargs
-        )
-
-        self._app_name = ''
-        self._last_signal = None
-        self._vendor_is_gnome = False
-        self._replace_id = 0
-        self._server_info = {}
-        self._broken_signals = []
-        self._actions = []
-        self._callbacks = {}
-        self._hints = {}
-
-    @classmethod
-    def async_init(cls, app_name, callback):
-        def on_init_finish(self, result, data):
-            try:
-                self.init_finish(result)
-            except GLib.Error as e:
-                callback(None, None, None, error=e)
-            else:
-                if not self.get_name_owner():
-                    callback(None, None, None, error='Notification service is unowned')
-                else:
-                    self.call(
-                        'GetCapabilities',
-                        None,
-                        Gio.DBusCallFlags.NONE,
-                        -1,
-                        None,
-                        on_GetCapabilities_finish,
-                        None,
-                    )
-
-        def on_GetCapabilities_finish(self, result, data):
-            try:
-                caps = self.call_finish(result).unpack()[0]
-            except GLib.Error as e:
-                callback(None, None, None, error=e)
-            else:
-                self.call(
-                    'GetServerInformation',
-                    None,
-                    Gio.DBusCallFlags.NONE,
-                    -1,
-                    None,
-                    on_GetServerInformation_finish,
-                    caps,
-                )
-
-        def on_GetServerInformation_finish(self, result, caps):
-            try:
-                info = self.call_finish(result).unpack()
-            except GLib.Error as e:
-                callback(None, None, None, error=e)
-            else:
-                self._server_info = {
-                    'name': info[0],
-                    'vendor': info[1],
-                    'version': info[2],
-                    'spec_version': info[3],
-                }
-                self._vendor_is_gnome = info[1] == 'GNOME'
-                self._app_name = app_name
-
-                callback(self, self._server_info, caps)
-
-        self = cls()
-        self.init_async(GLib.PRIORITY_DEFAULT, None, on_init_finish, None)
-
-    def show_new(self, summary, body, icon):
-        def on_Notify_finish(self, result):
-            self._replace_id = self.call_finish(result).unpack()[0]
-
-        # If the Notification server implementation's 'ActionInvoked' signal is broken
-        # our action buttons will be non-functional, so don't add them.
-        actions = self._actions if 'ActionInvoked' not in self._broken_signals else []
-        args = GLib.Variant('(susssasa{sv}i)', (self._app_name, self._replace_id,
-                                                icon, summary, body,
-                                                actions, self._hints, -1))
-
-        self.call(
-            'Notify',
-            args,
-            Gio.DBusCallFlags.NONE,
-            -1,
-            None,
-            on_Notify_finish,
-        )
-
-    def add_action(self, action_id, label, callback):
-        self._actions += [action_id, label]
-        self._callbacks[action_id] = callback
-
-    def clear_actions(self):
-        self._actions.clear()
-        self._callbacks.clear()
-
-    def set_hint(self, key, value):
-        if value is None:
-            if key in self._hints:
-                del self._hints[key]
-        else:
-            self._hints[key] = value
-
-    def do_g_signal(self, sender_name, signal_name, parameters):
-        try:
-            notification_id, signal_value = parameters.unpack()
-        except ValueError:
-            # Deepin's notification system is broken, see:
-            # https://github.com/gnumdk/lollypop/issues/1203
-            # This will stop exceptions by ignoring parameters
-            # and send a warning message about the broken signal.
-            # Don't spam the logs only send 1 warning message per signal name.
-            if signal_name not in self._broken_signals:
-                self._broken_signals.append(signal_name)
-                server_info = '\n'.join(('{}: {}'.format(k, v) for k, v in self._server_info.items()))
-                logging.warning('Broken Notification server implementation.\n'
-                                'Missing parameter(s) for the "{}" signal.\n'
-                                'Please file a bug report with the developers '
-                                'of your current Notification server:\n{}'.format(signal_name, server_info))
-        else:
-            # We only care about our notifications.
-            if notification_id != self._replace_id:
-                return
-            if self._vendor_is_gnome:
-                # In GNOME this stops multiple redundant 'NotificationClosed'
-                # signals from being emmitted. see: https://bugzilla.gnome.org/show_bug.cgi?id=790636
-                if (notification_id, signal_name) == self._last_signal:
-                    return
-                self._last_signal = notification_id, signal_name
-            if signal_name == 'ActionInvoked':
-                if signal_name not in self._broken_signals:
-                    callback = self._callbacks.get(signal_value)
-                    if callback:
-                        self.emit('action-invoked', signal_value)
-                        callback()
-                    else:
-                        self._broken_signals.append(signal_name)
-                        server_info = '\n'.join(('{}: {}'.format(k, v) for k, v in self._server_info.items()))
-                        logging.warning('Broken Notification server implementation.\n'
-                                        'Invalid "ActionInvoked" signal value: "{}".\n'
-                                        'Please file a bug report with the developers '
-                                        'of your current Notification server:\n{}'.format(signal_value, server_info))
-            elif signal_name == 'NotificationClosed':
-                if signal_name not in self._broken_signals:
-                    try:
-                        closed_reason = GioNotify.Closed(signal_value)
-                    except ValueError:
-                        self._broken_signals.append(signal_name)
-                        server_info = '\n'.join(('{}: {}'.format(k, v) for k, v in self._server_info.items()))
-                        logging.warning('Broken Notification server implementation.\n'
-                                        'Invalid "NotificationClosed" signal value: "{}".\n'
-                                        'Please file a bug report with the developers '
-                                        'of your current Notification server:\n{}'.format(signal_value, server_info))
-                    else:
-                        self.emit('closed', closed_reason)
-            else:
-                logging.debug('Unknown signal: "{}", value: "{}"'.format(signal_name, signal_value))
-
-    def __getattr__(self, name):
-        # PyGObject ships an override that breaks our usage.
-        return object.__getattr__(self, name)
diff --git a/pithos/plugins/notify.py b/pithos/plugins/notify.py
index dfc6688b..e712f373 100644
--- a/pithos/plugins/notify.py
+++ b/pithos/plugins/notify.py
@@ -12,107 +12,63 @@
 # You should have received a copy of the GNU General Public License along
 # with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import html
+import os
 import logging
 
-from gi.repository import (GLib, Gtk)
+from gi.repository import Gio
 
 from pithos.plugin import PithosPlugin
 
-from .dbus_util.GioNotify import GioNotify
-
 
 class NotifyPlugin(PithosPlugin):
     preference = 'notify'
     description = 'Shows notifications on song change'
 
-    notification = None
-    supports_actions = False
-    escape_markup = False
+    _app = None
+    _last_id = ''
 
     def on_prepare(self):
-        def on_notify_init_finish(notification, server_info, caps, error=None):
-            if error:
-                logging.warning('Notification server not found: {}'.format(error))
-                self.prepare_complete(error='Notification server not found')
-            else:
-                self.notification = notification
-                self.supports_actions = 'actions' in caps
-                self.escape_markup = 'body-markup' in caps
-
-                self.notification.set_hint('desktop-entry', GLib.Variant('s', 'io.github.Pithos'))
-                self.notification.set_hint('category', GLib.Variant('s', 'x-gnome.music'))
-                if 'action-icons' in caps:
-                    self.notification.set_hint('action-icons', GLib.Variant('b', True))
-
-                # GNOME Shell 3.20 or higher has bultin MPRIS functionality that makes
-                # persistent song notifications redundant.
-                has_built_in_mpris = False
-                version = server_info['version'].split('.')
-                if server_info['name'] == 'gnome-shell' and len(version) >= 2:
-                    major_version, minor_version = (int(x) if x.isdigit() else 0 for x in version[0:2])
-                    if major_version == 3 and minor_version >= 20:
-                        has_built_in_mpris = True
-
-                if 'persistence' in caps and has_built_in_mpris:
-                    self.notification.set_hint('transient', GLib.Variant('b', True))
-
-                server_info = '\n'.join(('{}: {}'.format(k, v) for k, v in server_info.items()))
-                logging.debug('\nNotification Server Information:\n{}'.format(server_info))
-
-                caps = '\n'.join((cap for cap in caps))
-                logging.debug('\nNotification Server Capabilities:\n{}'.format(caps))
-                self.prepare_complete()
-
-        GioNotify.async_init('Pithos', on_notify_init_finish)
+        # We prefer the behavior of the fdo backend to the gtk backend
+        # as it doesn't force persistance which doesn't make sense for
+        # this application.
+        if not os.path.exists('/.flatpak-info'):
+            os.environ['GNOTIFICATION_BACKEND'] = 'freedesktop'
+
+        self._app = Gio.Application.get_default()
+        self.prepare_complete()
 
     def on_enable(self):
         self.song_change_handler = self.window.connect('song-changed', self.send_notification)
         self.state_change_handler = self.window.connect('user-changed-play-state', self.send_notification)
-        self.closed_handler = self.notification.connect('closed', self.on_notification_closed)
-        self.action_invoked_handler = self.notification.connect('action-invoked', self.on_notification_action_invoked)
-
-    def on_notification_closed(self, notification, closed_reason):
-        logging.debug(closed_reason.explanation)
-
-    def on_notification_action_invoked(self, notification, action_id):
-        logging.debug('Notification action invoked: {}'.format(action_id))
-
-    def set_actions(self, playing):
-        pause_action = 'media-playback-pause'
-        play_action = 'media-playback-start'
-        skip_action = 'media-skip-forward'
-        if Gtk.Widget.get_default_direction() == Gtk.TextDirection.RTL:
-            play_action += '-rtl'
-            skip_action += '-rtl'
-        if playing:
-            self.notification.add_action(pause_action, 'Pause',
-                                         self.window.playpause_notify)
-        else:
-            self.notification.add_action(play_action, 'Play',
-                                         self.window.playpause_notify)
-
-        self.notification.add_action(skip_action, 'Skip',
-                                     self.window.next_song)
 
     def send_notification(self, window, *ignore):
         if window.is_active():
             return
-        if self.supports_actions:
-            self.notification.clear_actions()
-            self.set_actions(window.playing is not False)
+
         song = window.current_song
-        summary = song.title
-        body = 'by {} from {}'.format(song.artist, song.album)
-        if self.escape_markup:
-            body = html.escape(body, quote=False)
-        icon = song.artUrl or 'audio-x-generic'
-        self.notification.show_new(summary, body, icon)
+        # This matches GNOME-Shell's format
+        notification = Gio.Notification.new(song.artist)
+        notification.set_body(song.title)
+        if song.artUrl:
+            notification.set_icon(Gio.FileIcon.new(Gio.File.new_for_uri(song.artUrl)))
+
+        if window.playing:
+            notification.add_button(_('Pause'), 'app.pause')
+        else:
+            notification.add_button(_('Play'), 'app.play')
+        notification.add_button(_('Skip'), 'app.next-song')
+
+        if self._last_id != song.trackToken:
+            self._app.withdraw_notification(self._last_id)
+
+        self._last_id = song.trackToken
+        self._app.send_notification(song.trackToken, notification)
 
     def on_disable(self):
-        if self.notification is None:
-            return
+        if self._last_id:
+            self._app.withdraw_notification(self._last_id)
+            self._last_id = ''
+
         self.window.disconnect(self.song_change_handler)
         self.window.disconnect(self.state_change_handler)
-        self.notification.disconnect(self.closed_handler)
-        self.notification.disconnect(self.action_invoked_handler)
+
